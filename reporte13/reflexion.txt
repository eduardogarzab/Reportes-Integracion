En este reporte se implementó desde cero un microservicio en Flask destinado a gestionar imágenes para el catálogo de libros. Se integró el SDK de Azure Blob Storage para subir archivos desde peticiones multipart, se generaron URLs firmadas (SAS) para acceso temporal, y se registraron metadatos relevantes (nombre de blob, tamaño, tipo MIME y timestamp) en una base de datos MariaDB. Además, se añadió protección por token Bearer y soporte para respuestas en XML o JSON, siguiendo las especificaciones documentadas en Swagger.

Durante el desarrollo surgieron y se resolvieron varias decisiones importantes: elegir nombres únicos para blobs para evitar colisiones, manejar transacciones para garantizar consistencia entre el almacenamiento en la nube y el registro en la base de datos, y validar tipos y tamaños para prevenir subidas malformadas. También se trabajó la generación del User Delegation Key y la firma SAS, contemplando el caso en que el Service Principal no tenga permisos para delegación y dejando un fallback informativo. Los archivos de configuración y dependencias se centralizaron en `requirements.txt` y en variables de entorno para facilitar despliegues seguros.

Como conclusión, el ejercicio permitió practicar la integración entre servicios cloud y microservicios locales, pensar en la consistencia y la seguridad de las operaciones (reversión en caso de fallo de BD, límites de tamaño), y dejar una API usable desde la UI para subir, listar y consumir imágenes. Como siguientes pasos recomendados están añadir tests automatizados (unitarios e integración con un contenedor emulado de Azure o Azurite), instrumentación/telemetría y políticas de retención/limpieza de blobs antiguos.
