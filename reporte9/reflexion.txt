Desarrollar este ejercicio fue un proceso enriquecedor que permitió comprender de forma práctica cómo los microservicios pueden interactuar entre sí, independientemente del lenguaje o framework con el que estén implementados. La clave estuvo en el uso de APIs bien estructuradas, autenticación basada en JWT, y formatos estándar como JSON y XML, que hacen posible que una aplicación en Python consuma servicios escritos con diferentes tecnologías.

Al integrar ambos microservicios —uno de autenticación y otro de gestión de libros— mediante una interfaz en Tkinter, se reforzó el concepto de separación de responsabilidades y comunicación por medio de HTTP. Implementar un cliente de escritorio que maneje sesiones, tokens, refresco de credenciales y consumo de endpoints protegidos permitió observar de primera mano el ciclo completo de autenticación y autorización, lo cual es fundamental en aplicaciones reales.

El desarrollo de la interfaz gráfica también trajo aprendizajes sobre usabilidad y manejo de estados. Agregar elementos visuales como los semáforos de estado ayudó a visualizar el funcionamiento y disponibilidad de los servicios de manera intuitiva. Además, la persistencia local de configuración simuló el comportamiento de un almacenamiento tipo localStorage, permitiendo mantener la conexión a los microservicios sin necesidad de reconfigurar cada vez.

La implementación de logs en tiempo real dentro de la interfaz sirvió no solo como herramienta de depuración, sino también como forma de entender la trazabilidad de las peticiones y respuestas HTTP. Visualizar los tokens generados y los mensajes de éxito o error fomentó una comprensión más clara del flujo interno de comunicación entre cliente y servidor.

Este ejercicio también permitió reflexionar sobre la importancia de la estandarización en la arquitectura de software. No importa si un servicio está hecho en Flask, FastAPI, Node.js o Java — mientras se cumplan principios REST y se manejen adecuadamente los encabezados, el cliente podrá interactuar sin problemas. Esto demuestra que la interoperabilidad no depende de la tecnología elegida, sino de las buenas prácticas de diseño.

Otra enseñanza significativa fue el manejo de errores y excepciones. Incorporar mensajes claros en la interfaz cuando un servicio no responde o devuelve un código de error 4xx/5xx es esencial para que el usuario entienda qué ocurre, en lugar de enfrentarse a fallos silenciosos. Este aspecto, aunque técnico, tiene un impacto directo en la experiencia del usuario y en la confiabilidad del sistema.

En cuanto al uso de Tkinter, el proyecto mostró que las aplicaciones de escritorio aún tienen cabida en entornos modernos, especialmente como herramientas administrativas o clientes internos. Su simplicidad y compatibilidad con librerías como `requests` hacen posible crear frontends ligeros pero potentes para interactuar con servicios distribuidos.

En general, el proyecto integró conocimientos de varias áreas: desarrollo backend, arquitectura de microservicios, comunicación cliente-servidor, autenticación, manejo de tokens, visualización de datos XML, y diseño de interfaces gráficas. Cada parte aportó una perspectiva distinta sobre cómo los sistemas modernos se comunican y cómo la modularidad facilita la escalabilidad y el mantenimiento.

Finalmente, este ejercicio sirvió como una demostración tangible de que el valor de un sistema distribuido no reside únicamente en su complejidad técnica, sino en su capacidad para conectar componentes heterogéneos de forma eficiente, confiable y reutilizable. La experiencia dejó claro que la integración efectiva entre servicios no depende del lenguaje, sino de los principios universales de diseño de software: claridad, consistencia, documentación y robustez en la comunicación.